# 请简述JVM垃圾回收原理

## 垃圾回收原理
Java 堆中存放着几乎所有的对象实例，回收之前要确定其是否存活着，有两种思路可以判断对象存活

### 引用计数算法
如果有其他对象对其引用，则计数器加一，引用失效的时候，计数器减一。计数器为0时则可以被回收。

弊端：无法解决对象互相引用的问题，他们是内存中的孤岛，但却无法被回收 例如： A.a = B;B.b = A

### 可达性分析算法
通过一系列称为GC Roots的对象作为起始点，然后向下搜索，走过的路径为引用链，如果一个对象到GC Roots 没有任何引用链，则说明此对象是不可达（不可用）的。


## 垃圾回收算法
### 标记-清除算法（Mark-Sweep）
标记阶段标记出所有要回收的对象，标记完成后统一回收。

缺点：效率不高；内存不连续，导致之后需要分配大对象时无法找到足够的连续内存而再次进行垃圾回收。

### 复制算法（Copying）
将可用内存按容量划分为大小相等的两块，每次只用其中一块。用完一块后将上面还存活的对象复制到另外一块上。这样就没有碎片的问题了。

缺点：内存被缩小为之前的一半，代价太高。

但实际商业上新生代都是按照复制算法进行回收的，因为大多对象都是朝生夕死，所以并不是按1:1划分，而是将内存分为较大的 Eden空间和两块较小的 Survivor 空间。比例为8:1:1，这样可用空间就大大提升了。

### 标记-整理算法（Mark-Compact）
与标记-整理算法一样，但是不是直接对可回收对象进行清理，而是让所有存活的向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法
本质上不是一种算法，而是根据对象存活周期的不同将内存划分为几块。Java 堆一般分为新生代和老年代。会根据不同代的特点选用不同的算法。